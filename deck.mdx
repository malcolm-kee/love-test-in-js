export { book as theme } from 'mdx-deck/themes';

import { Appear, Head, Image, Notes } from 'mdx-deck';
import { Invert } from 'mdx-deck/layouts';
import CodeSurfer from './components/code-surfer';
import Scripts from './components/scripts';
import TestingQuotient from './components/testing-quotient';

<Head>
  <title>How to Love Writing JavaScript Tests</title>
</Head>

export default Invert;

# How to Love Writing JavaScript Tests

maybe for other language too? ü§∑

---

<TestingQuotient />

<Notes>

Raise hand to see the statistics about quotient

</Notes>

---

<TestingQuotient highlighted />

---

<CodeSurfer
  code={require('!!raw-loader!./snippets/1.js')}
  steps={[
    { notes: 'How test looks like' },
    { range: [1, 14], notes: 'Code to be tested' },
    { range: [17, 30], notes: 'The test' }
  ]}
/>

<Notes>

A simple example of test for those that never write tests.

</Notes>

---

## Automated testing

- do what a manual testing does, i.e. catch bug
- gives you confidence when change your code

---

> "To me, _legacy code_ is simply code without tests. <br />... <br /> Code without tests is bad code."

&mdash; Michael C. Feathers (in Working Effectively with Legacy Code)

---

<Image src="images/testing_pyramid.png" />

<Notes>

- Testing pyramid is one of the most popular concepts when talking about automated testing
- Write most unit tests because they are fast and good feedback loop.
- Write less integration tests because they are slow and more effort to write and investigate.

</Notes>

---

# Why I hated writing JavaScript tests

<Notes>

Let me share with you why I used to hate writing tests.

</Notes>

---

## 1. Efforts and tedious (add code + bug fix)

<Notes>

- too much effort to maintain.
- add new code, tests may fail, need to fix it.
- Same goes to bug fix, refactor, test fail, need fix.
- **It is frustrating and boring.**

</Notes>

---

## 2. Doesn't catch my bug

<Notes>

- Add on top of the frustration is the tests never catch bugs at all.
- It is very frequent that all tests pass, bugs still happens.

</Notes>

---

## 3. "If I'm a good developer, my code shouldn't have bug."

<Notes>

- good code is should be easy to read and understand.
- good code shouldn't have bug
- the only bug is due to misunderstanding of requirement, which test can't catch

</Notes>

---

<CodeSurfer
  code={require('!!raw-loader!./snippets/unit-test-2.js')}
  steps={[
    { notes: 'An example of unit test' },
    { range: [1, 13], notes: 'Code to be tested' },
    {
      tokens: {
        8: [0, 1, 2],
        10: [0, 1, 2, 3, 4, 5, 6]
      },
      notes: 'These are the places we use jquery'
    },
    { range: [15, 40], notes: 'The test' },
    {
      range: [16, 28],
      notes:
        'Mocking jquery so we only test getPokemonData and nothing else'
    },
    {
      range: [30, 44],
      notes: 'Making assertion about getPokemonData'
    },
    {
      notes: 'This is PITA'
    }
  ]}
/>

---

export default Invert;

## Is the value of automated testing a myth?

---

# Lesson #1: Test it at "Right" Level of Isolation

---

<blockquote className="twitter-tweet">
  <p lang="en" dir="ltr">
    Write tests. Not too many. Mostly integration.
  </p>
  &mdash; Guillermo ‚ñ≤ (@rauchg) <a href="https://twitter.com/rauchg/status/807626710350839808?ref_src=twsrc%5Etfw">December 10, 2016</a>
</blockquote>

<Notes>

- Guillermo (creator of socket.io)
- We're talk about the two tips he give, "mostly integration" and "not too many".

</Notes>

---

## The higher level the test is, the more likely it will catch the bug that our limited mental power could not predict.

---

## The higher level the test is, the more it resembles how our code is being used, the more confidence we could gain from it.

---

<Image src="images/man_push_up.gif" />

---

<Image src="images/testing_pyramid_with_tradeoff.png" />

---

## Test is like security. Too much of it will cause the "safest" result: do nothing.

## So...

---

## Test public API (which is usually involves integration of multiple "units" in your code)

---

<blockquote className="twitter-tweet">
  <p lang="en" dir="ltr">
    The common wisdom is that unit tests make refactoring harder, but
    for React, the opposite has been true. I do huge rewrites several
    times a year, and I‚Äôm only able to do so because our test suite
    provides so much safety.
    <br />
    <br />
    When people say, ‚Äúonly test the public API,‚Äù this is why!
  </p>
  &mdash; Andrew Clark (@acdlite)
  <a href="https://twitter.com/acdlite/status/1105318434085040128?ref_src=twsrc%5Etfw">
    March 12, 2019
  </a>
</blockquote>

---

## and private API that you feel less confident.

---

# Lesson #2: Test code is code too

---

## keep it DRY (but don't overdo it)

---

<CodeSurfer
  code={require('!!raw-loader!./snippets/repetition-in-test.js')}
  steps={[
    { notes: 'An example of test' },
    { range: [1, 3], notes: 'Import helpers and code to be tested' },
    { range: [5, 19], notes: 'Test that verify positive scenario' },
    {
      range: [21, 35],
      notes: 'Test that verify validation'
    }
  ]}
/>

---

<CodeSurfer
  code={require('!!raw-loader!./snippets/dry-in-test.js')}
  steps={[
    { notes: 'How to make your test DRY' },
    {
      range: [5, 30],
      notes: 'Create a setup method and returns meaningful functions'
    },
    {
      range: [10, 22]
    },
    {
      range: [24, 29]
    },
    { range: [33, 41], notes: 'Use the setup method in your test' },
    {
      range: [43, 57],
      notes: 'Another test'
    }
  ]}
/>

---

## it's all tradeoff

---

# How to Get Started

---

## [`@testing-library`](https://testing-library.com/)

- `@testing-library/angular`
- `@testing-library/cypress`
- `@testing-library/react`
- `@testing-library/svelte`
- `@testing-library/vue`

---

export default Invert;

# Give It a Try

<Appear>
  <h2>Questions?</h2>
</Appear>

<Scripts scriptSrc="https://platform.twitter.com/widgets.js" />
